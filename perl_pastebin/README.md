# Учебный проект: Pastebin-сервис с Observability-стеком

Это учебный проект, созданный в рамках домашнего задания по теме "Observability (o11y)".

**Цель:** развернуть полноценный веб-сервис и всю необходимую инфраструктуру для его мониторинга, сбора метрик, визуализации, алертинга и анализа производительности.

**Технологический стек:**

*   **Бэкенд:** `Perl` на фреймворке `Mojolicious`
*   **База данных:** `CouchDB` (NoSQL)
*   **Инфраструктура:** `Docker` и `Docker Compose`
*   **Мониторинг:** `Prometheus`, `Grafana`, `Alertmanager`, `couchdb-exporter`
*   **Нагрузочное тестирование:** `Locust`
*   **Дополнительно:** `Nginx`, `Swagger`, `Jaeger`, `Devel::NYTProf`

## Архитектура системы

Система состоит из множества взаимосвязанных сервисов, управляемых через `docker-compose`.

![Архитектура](/images/architecture.svg)

## Подготовка и запуск

### 1. Пререквизиты
*   `Docker`
*   `Docker Compose`
*   Командная оболочка `bash` или `zsh` для запуска управляющего скрипта.

### 2. Настройка секретов
Для отправки алертов в Telegram необходимо указать токен вашего бота.

1.  Создайте директорию `secrets` в корне проекта: `mkdir secrets`
2.  Внутри нее создайте файл `telegram_bot_token`.
3.  Поместите в этот файл токен вашего бота (без кавычек и лишних символов).

*Примечание: ID чата для отправки алертов уже указан в файле `alertmanager/config.yml`.*

### 3. Запуск через управляющий скрипт
Для управления проектом используется единый скрипт `./run.sh`. **Сначала сделайте его исполняемым:**
```bash
chmod +x run.sh
```

#### Обычный запуск
Для запуска всех сервисов в стандартном (быстром) режиме в фоновом режиме, выполните:
```bash
./run.sh
```

#### Запуск в режиме профилирования
Для запуска приложения под профилировщиком `NYTProf` для анализа производительности, передайте флаг `profile`:
```bash
./run.sh profile
```
При запуске в этом режиме логи будут выводиться прямо в консоль. После завершения теста нажмите `Ctrl+C`, и результаты профилирования будут автоматически доступны в папке `./profiling_results/`.

## Куда смотреть: все эндпоинты

| Назначение | URL в браузере | Учетные данные |
| :--- | :--- | :--- |
| **Основной сервис Pastebin** | `http://localhost:8080` | - |
| **Эта документация** | `http://localhost:8080/docs` | - |
| **Дашборд с графиками (Grafana)** | `http://localhost:3100` | `admin` / `admin` |
| **Нагрузочный стенд (Locust)** | `http://localhost:8089` | - |
| **Документация API (Swagger)** | `http://localhost:8081` | - |
| **Распределенный трейсинг (Jaeger)**| `http://localhost:16686`| - |
| **Консоль Prometheus** | `http://localhost:9090` | - |

## Как воспроизвести алерты

1.  Убедитесь, что система запущена в **обычном режиме** (`./run.sh`).
2.  Откройте в браузере дашборд в **Grafana** и ваш **Telegram-канал**.
3.  Откройте **Locust** (`http://localhost:8089`).
4.  Настройте и запустите нагрузку:
    *   **Number of users:** `200`
    *   **Spawn rate:** `10`
    *   **Host:** `http://nginx`
5.  Наблюдайте за графиками в Grafana. Через 1-2 минуты вы увидите:
    *   **Service Latency (p99)** превысит 500ms.
    *   **Database Operations (RPS)** превысит 100.
6.  В течение следующей минуты в Telegram-канал придут два алерта (`HighRequestLatency` и `HighDatabaseRPS`) с подробным описанием.

## Расположение IaC-конфигураций

*   **Правила Алертинга (Prometheus):** `prometheus/alert.rules.yml`
*   **Конфигурация Дашборда (Grafana):** `grafana/provisioning/dashboards/dashboard.json`
*   **Конфигурация Источника Данных (Grafana):** `grafana/provisioning/datasources/datasource.yml`

## Бонусные возможности

### Трейсинг (Jaeger)
Во время нагрузочного теста перейдите в интерфейс Jaeger (`http://localhost:16686`). В выпадающем списке `Service` выберите `pastebin-perl-app` и нажмите `Find Traces`. Вы увидите подробный путь каждого запроса через систему.

### Профилирование кода (Пункт 8)
В проект встроен повторяемый механизм анализа производительности кода.
*   **Как использовать:** Запустите систему с помощью `./run.sh profile` и дайте нагрузку. После остановки (`Ctrl+C`) результаты будут сохранены в папку `./profiling_results/`.
*   **Проблема:** В код была искусственно добавлена ресурсоемкая функция `create_artificial_delay`.
*   **Поиск:** С помощью `NYTProf` был сгенерирован отчет, который точно указал на эту функцию и строку ее вызова как на основную причину замедления.
*   **Решение:** Проблемная строка была закомментирована.
*   **Доказательство:** Весь процесс записан на предоставленном **скринкасте**. Вы можете найти закомментированную строку в файле `pastebin.pl` для справки, а также артефакты конфигурации профилирования в файле `profiling.override.yml`.