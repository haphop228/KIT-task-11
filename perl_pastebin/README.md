# Cервис Pastebin с полным стеком Observability

Этот проект представляет собой реализацию простого сервиса "Pastebin" на языке **Perl** с использованием фреймворка **Mojolicious**. Главной целью проекта является демонстрация полного стека o11y (Observability), включающего метрики, логирование, трейсинг, алертинг и профилирование.

## Оглавление

*   [Архитектура](#архитектура)
*   [Как запустить](#как-запустить)
*   [Доступные сервисы (Endpoints)](#доступные-сервисы-endpoints)
*   [Документация (пункт 0)](#документация-пункт-0)
*   [Бизнес-логика сервиса (пункт 1)](#бизнес-логика-сервиса-пункт-1)
*   [Нагрузочное тестирование (пункт 2)](#нагрузочное-тестирование-пункт-2)
*   [База данных (пункт 3)](#база-данных-пункт-3)
*   [Графики и Алерты (пункт 4)](#графики-и-алерты-пункт-4)
    *   [Графики](#графики)
    *   [Алерты](#алерты)
    *   [Как воспроизвести алерты](#как-воспроизвести-алерты)
*   [Infrastructure as Code (пункт 5)](#infrastructure-as-code-пункт-5)
*   [**Бонусные пункты**](#бонусные-пункты)
    *   [Swagger / OpenAPI (пункт 6)](#swagger--openapi-пункт-6)
    *   [Трейсинг (пункт 7)](#трейсинг-пункт-7)
    *   [Профилирование производительности (пункт 8)](#профилирование-производительности-пункт-8)
    *   [Новая БД и Язык (пункты 9-10)](#новая-бд-и-язык-пункты-9-10)

## Архитектура

Проект состоит из набора Docker-контейнеров, управляемых через `docker-compose`.

![Архитектура проекта](/images/architecture2.svg)

**Ключевые компоненты:**

*   **Pastebin Service (`pastebin.pl`)**: Основное приложение на Perl/Mojolicious.
*   **Nginx**: Выступает в роли реверс-прокси.
*   **CouchDB**: NoSQL база данных для хранения "паст".
*   **Locust**: UI для проведения нагрузочного тестирования.
*   **Prometheus**: Сбор и хранение метрик.
*   **Grafana**: Визуализация метрик и логов.
*   **Loki**: Агрегация и хранение логов.
*   **Promtail**: Агент для сбора логов и отправки в Loki.
*   **Alertmanager**: Управление и отправка алертов.

## Как запустить

**Предварительные требования:** Установленные `docker` и `docker-compose`.

1.  **Секреты:** Создайте файл `secrets/telegram_chat_id` поместите в него соответствующее значение, а также укажите свой `telegram_chat_id` в `alertmanager/config.yml`.

2.  **Запуск:** Для обычного запуска выполните команду:
    ```bash
    ./run.sh
    ```
    Эта команда запустит все сервисы в фоновом режиме.

## Доступные сервисы (Endpoints)

*   **Pastebin UI**: `http://localhost:8080`
*   **Locust (Нагрузочный UI)**: `http://localhost:8089`
*   **Grafana**: `http://localhost:3100` (логин/пароль: admin/admin)
*   **Prometheus**: `http://localhost:9090`
*   **Alertmanager**: `http://localhost:9093`
*   **Swagger UI (API Docs)**: `http://localhost:8081`

---

## Документация (пункт 0)

Данный `README.md` файл является основной документацией. Его версия в формате HTML также доступна непосредственно в работающем приложении по адресу:

*   **http://localhost:8080/docs**

Это реализовано с помощью рендеринга Markdown-файла внутри Perl-приложения.

## Бизнес-логика сервиса (пункт 1)

**Pastebin** — это простой сервис, позволяющий пользователям анонимно публиковать фрагменты текста или кода.

*   **Создание "пасты"**: На главной странице (`/`) пользователь может вставить текст, выбрать язык подсветки синтаксиса и сохранить. После сохранения его перенаправляет на уникальную страницу созданной "пасты".
*   **Просмотр "пасты"**: Каждая "паста" доступна по уникальному URL вида `/paste/:id`.

Сервис написан на языке **Perl** с использованием асинхронного веб-фреймворка **Mojolicious**. В качестве веб-сервера используется **Hypnotoad**, который запускает 1-го worker'а для обработки входящих запросов.

## Нагрузочное тестирование (пункт 2)

Для нагрузочного тестирования используется **Locust**.

*   **UI для запуска**: `http://localhost:8089`

В Locust UI вы можете указать количество симулируемых пользователей (`Number of users`) и скорость их появления (`Spawn rate`). 

## База данных (пункт 3)

В качестве основной базы данных используется **CouchDB** — документо-ориентированная NoSQL СУБД. Она выбрана за простоту установки и использования. Каждая "паста" хранится как отдельный JSON-документ.

## Графики и Алерты (пункт 4)

### Графики

Все графики доступны в **Grafana** (`http://localhost:3100`).

1.  **`1. Service Overview`**: Обзорный дашборд с ключевыми метриками сервиса: статус, общая частота запросов (RPS), p99 времени ответа и процент ошибок.
2.  **`2. Application Internals`**: Детализированный дашборд с метриками для worker'а. Показывает использование CPU и памяти, а также RPS для worker'а.
3.  **`3. Database Health`**: Дашборд, посвященный метрикам CouchDB. Показывает:
    *   Статус экспортера метрик.
    *   Количество документов и размер базы.
    *   **RPS на БД** со стороны сервиса.
    *   Внутреннее время ответа CouchDB (p99).

### Алерты

Алерты настроены в Prometheus и отправляются в публичный Telegram-канал через Alertmanager.

*   **Ссылка на Telegram-канал**: [https://t.me/alertsperlpastebin]

Настроено 2 алерта:

1.  `HighRequestLatency` (Critical): Срабатывает, если суммарное время ответа (очередь + обработка) в p99 превышает **500 мс** в течение 1 минуты.
2.  `HighDatabaseRPS` (Warning): Срабатывает, если скорость запросов к базе данных превышает **100 RPS** в течение 30 секунд.

### Как воспроизвести алерты

1.  **`HighDatabaseRPS`**:
    *   Откройте Locust (`http://localhost:8089`).
    *   Запустите нагрузочный тест с параметрами >400 RPS (например, 400 пользователей, spawn rate 100).
    *   Примерно через 30 секунд в Telegram придет первый алерт.

2.  **`HighRequestLatency`**:
    *   В файле `pastebin.pl` раскомментируйте строку `create_artificial_delay();` внутри маршрута `post '/'`. Эта функция имитирует ресурсоемкую операцию, увеличивая время ответа.
    *   Пересоберите и перезапустите сервис: `./run.sh`.
    *   Запустите нагрузочный тест с параметрами >400 RPS (например, 400 пользователей, spawn rate 100).
    *   Примерно через 1 минуту в Telegram придет алерт о высокой задержке.

## Infrastructure as Code (пункт 5)

Все компоненты инфраструктуры, включая графики и алерты, описаны в коде (Infrastructure as Code).

*   **Инфраструктура**: Описана в `docker-compose.yml`.
*   **Конфигурация Grafana**:
    *   **Источники данных**: `grafana/provisioning/datasources/datasource.yml`
    *   **Дашборды**: лежат в формате JSON в `grafana/provisioning/dashboards/`.
*   **Конфигурация Prometheus**:
    *   **Основные настройки и цели**: `prometheus/prometheus.yml`
    *   **Правила алертов**: `prometheus/alert.rules.yml`
*   **Конфигурация Alertmanager**: `alertmanager/config.yml`

---

## **Бонусные пункты**

### Swagger / OpenAPI (пункт 6)

API сервиса документировано с помощью спецификации OpenAPI v3. Для интерактивной работы с API развернут **Swagger UI**.

*   **Swagger UI**: `http://localhost:8081`
*   **Спецификация**: `public/openapi.json`

Swagger UI позволяет просматривать все доступные эндпоинты, их параметры и отправлять тестовые запросы напрямую из браузера.

### Трейсинг (пункт 7)

В проекте реализована легковесная система трассировки **"Poor man's tracing"** с использованием связки **Loki + Grafana**.

*   **Как это работает**: Каждому запросу присваивается уникальный `trace_id`, который записывается во все структурированные логи, относящиеся к этому запросу.
*   **Как пользоваться**:
    1.  Перейдите в Grafana -> Explore -> Loki.
    2.  Выполните запрос `{service="pastebin"} | json`.
    3.  Найдите поле `trace_id` в логах. Оно является **кликабельной ссылкой**.
    4.  При клике на `trace_id` Grafana автоматически выполнит новый поиск и покажет вам **все логи для этого конкретного трейса**.

Подробное руководство находится в файле `tracing_help.md`.

### Профилирование производительности (пункт 8)

Для поиска узких мест в коде используется перфоманс-инструмент **Devel::NYTProf**, специфичный для языка Perl.

*   **Как запустить**:
    ```bash
    ./run.sh profile
    ```
    Эта команда запускает сервис в режиме профилирования. После завершения теста в директории `profiling_results` появятся "сырые" данные.

*   **Скринкаст с демонстрацией**: [ССЫЛКА_НА_ВАШ_СКРИНКАСТ]
    *В скринкасте показан процесс обнаружения искусственно созданной проблемы производительности (функция `create_artificial_delay`), анализ отчета `nytprofhtml`, фикс проблемы в коде и демонстрация улучшения производительности после пересборки.*

### Новая БД и Язык (пункты 9-10)

Для выполнения этого задания были использованы не самые распространенные в подобных задачах технологии, что соответствует духу бонусов:
*   **"Новый" язык**: **Perl** с фреймворком Mojolicious.
*   **"Новая" БД**: **CouchDB**.